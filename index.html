<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLOv5 Real-time Browser Monitor</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 2rem; background-color: #f9f9f9; color: #333; display: flex; flex-direction: column; align-items: center; }
        .container { max-width: 90%; width: 100%; background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        canvas { max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px; margin-top: 1rem; background-color: #eee; }
        #startButton { font-size: 16px; padding: 12px 20px; cursor: pointer; border-radius: 5px; border: none; color: white; background-color: #0078D4; }
        #status { margin-top: 1rem; font-weight: bold; color: #555; }
    </style>
</head>
<body>

    <div class="container">
        <h1>YOLOv5 Real-time Browser Monitor</h1>
        <p>This demo runs YOLOv5 in your browser. Click the button below, then choose a browser tab to share for real-time object detection.</p>
        <button id="startButton">Start Detection</button>
        <p id="status">Waiting to start...</p>
        <canvas id="output-canvas"></canvas>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

    <script>
        const startButton = document.getElementById('startButton');
        const canvas = document.getElementById('output-canvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('status');
        let session;

        async function initialize() {
            try {
                statusText.textContent = "Loading model...";
                const modelUrl = './yolov5s.onnx'; // Using the model from our GitHub repo
                session = await ort.InferenceSession.create(modelUrl);
                statusText.textContent = "Model loaded. Click 'Start Detection'.";
                startButton.disabled = false;
            } catch (error) {
                console.error("Error loading model:", error);
                statusText.textContent = "Failed to load model. Check console.";
            }
        }

        startButton.addEventListener('click', async () => {
            try {
                statusText.textContent = "Requesting screen permission...";
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                const video = document.createElement('video');
                video.srcObject = stream;
                video.play();
                statusText.textContent = "Detection running...";
                startButton.style.display = 'none'; // Hide button after starting

                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    detectionLoop(video);
                };
            } catch (error) {
                console.error("Error starting screen capture:", error);
                statusText.textContent = "Could not start screen capture. Permission denied?";
            }
        });

        async function detectionLoop(video) {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            const preprocessedData = preprocess(canvas);
            const inputTensor = new ort.Tensor('float32', preprocessedData, [1, 3, 640, 640]);
            const feeds = { images: inputTensor };

            const results = await session.run(feeds);
            processOutput(results.output0.data, canvas.width, canvas.height);
            
            requestAnimationFrame(() => detectionLoop(video));
        }

        function preprocess(canvasSource) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 640;
            tempCanvas.height = 640;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvasSource, 0, 0, 640, 640);
            const imageData = tempCtx.getImageData(0, 0, 640, 640);
            const { data } = imageData;
            
            const red = [], green = [], blue = [];
            for (let i = 0; i < data.length; i += 4) {
                red.push(data[i] / 255.0);
                green.push(data[i + 1] / 255.0);
                blue.push(data[i + 2] / 255.0);
            }
            return [...red, ...green, ...blue];
        }

        function processOutput(output, imgWidth, imgHeight) {
            const boxes = [];
            const numClasses = 80;
            const numDetections = 8400;

            for (let i = 0; i < numDetections; i++) {
                let maxProb = 0;
                let classId = -1;
                for (let j = 0; j < numClasses; j++) {
                    const classProb = output[(j + 4) * numDetections + i];
                    if (classProb > maxProb) {
                        maxProb = classProb;
                        classId = j;
                    }
                }

                if (maxProb > 0.5) {
                    const centerX = output[0 * numDetections + i];
                    const centerY = output[1 * numDetections + i];
                    const width = output[2 * numDetections + i];
                    const height = output[3 * numDetections + i];
                    boxes.push({ classId, probability: maxProb, bounding: [centerX - width / 2, centerY - height / 2, width, height] });
                }
            }

            const finalBoxes = nonMaxSuppression(boxes);
            finalBoxes.forEach(box => drawBoundingBox(box, imgWidth, imgHeight));
        }

        function nonMaxSuppression(boxes, nmsThreshold = 0.45) {
            const finalBoxes = [];
            boxes.sort((a, b) => b.probability - a.probability);
            while (boxes.length > 0) {
                finalBoxes.push(boxes[0]);
                const boxA = boxes.shift();
                for (let i = boxes.length - 1; i >= 0; i--) {
                    const boxB = boxes[i];
                    if (boxA.classId === boxB.classId && iou(boxA.bounding, boxB.bounding) > nmsThreshold) {
                        boxes.splice(i, 1);
                    }
                }
            }
            return finalBoxes;
        }

        function iou(boxA, boxB) {
            const xA = Math.max(boxA[0], boxB[0]);
            const yA = Math.max(boxA[1], boxB[1]);
            const xB = Math.min(boxA[0] + boxA[2], boxB[0] + boxB[2]);
            const yB = Math.min(boxA[1] + boxA[3], boxB[1] + boxB[3]);
            const interArea = Math.max(0, xB - xA) * Math.max(0, yB - yA);
            const boxAArea = boxA[2] * boxA[3];
            const boxBArea = boxB[2] * boxB[3];
            return interArea / (boxAArea + boxBArea - interArea);
        }

        function drawBoundingBox(box, imgWidth, imgHeight) {
            const classNames = ['person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light', 'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow', 'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee', 'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard', 'tennis racket', 'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple', 'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch', 'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone', 'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear', 'hair drier', 'toothbrush'];
            const xRatio = imgWidth / 640;
            const yRatio = imgHeight / 640;
            const [x1, y1, width, height] = box.bounding;

            ctx.strokeStyle = '#00FF00';
            ctx.lineWidth = 3;
            ctx.strokeRect(x1 * xRatio, y1 * yRatio, width * xRatio, height * yRatio);
            
            const label = `${classNames[box.classId]} (${(box.probability * 100).toFixed(1)}%)`;
            ctx.fillStyle = '#00FF00';
            ctx.font = '18px Arial';
            ctx.textBaseline = 'top';
            ctx.fillText(label, x1 * xRatio, y1 * yRatio - 18);
        }

        // Initialize the app when the page loads
        initialize();
    </script>
</body>
</html>
